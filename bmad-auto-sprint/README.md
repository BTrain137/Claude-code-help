# BMAD Auto-Sprint Workflow

An autonomous sprint loop that cycles through the BMAD story lifecycle — **Create Story → Dev Story → Quality Gate → Code Review** — until the sprint scope is complete. Ralph-style YOLO execution with circuit breakers and quality gates.

## How It Works

The auto-sprint is a **meta-orchestrator** that spawns sub-agents for each phase:

```
┌─────────────────────────────────────────────────────────────┐
│                    AUTO-SPRINT LOOP                         │
│                                                             │
│  ┌──────────┐   ┌──────────┐   ┌──────────┐   ┌────────┐  │
│  │ Create   │──▶│ Dev      │──▶│ Quality  │──▶│ Code   │  │
│  │ Story    │   │ Story    │   │ Gate     │   │ Review │  │
│  │(sub-agent)  │(sub-agent)  │(orchestrator) │(sub-agent) │
│  └──────────┘   └──────────┘   └──────────┘   └────────┘  │
│       ▲              ▲                              │       │
│       │              │         NEEDS_REWORK ───────┘       │
│       │              └──────── (loop back to dev)          │
│       │                                                     │
│       └──── next story ◀──── DONE ──────────────────┘      │
│                                                             │
│  Circuit Breakers: max 20 iterations, 2 consecutive fails  │
└─────────────────────────────────────────────────────────────┘
```

### Key Design Decisions

1. **Sub-agents for context isolation** — Each story cycle runs in a fresh sub-agent to prevent context exhaustion during long sprints. The orchestrator keeps clean context for loop control.

2. **Quality gates in orchestrator context** — TypeScript build + tests run in the orchestrator (not sub-agent) for independent verification that the dev agent's work actually compiles.

3. **sprint-status.yaml as sole loop control** — Re-read on every iteration. No internal state tracking. Interrupted auto-sprints can be resumed by re-running the command.

4. **Circuit breakers** — `max_iterations: 20` (absolute cap) + `max_consecutive_failures: 2` (cascading failure protection).

5. **Scope control** — Three modes: `epic` (single epic), `all` (all epics), `count` (next N stories).

### Execution Modes

When launched, the orchestrator presents a scope configuration and asks:

- **y** (YOLO) — Fully autonomous, no stops between stories
- **c** (Confirm) — Pause for confirmation between each story cycle
- **s** (Scope) — Change scope before starting
- **q** (Quit) — Exit

## Prerequisites

- BMAD framework installed in project (`_bmad/` directory)
- Existing workflows: `create-story`, `dev-story`, `code-review`
- A `sprint-status.yaml` file (generated by `sprint-planning` workflow)

## Installation

### 1. Copy the command file

```bash
cp bmad-bmm-auto-sprint.md <project>/.library/commands/bmad/
```

### 2. Copy the workflow directory

```bash
cp -r auto-sprint/ <project>/_bmad/bmm/workflows/4-implementation/auto-sprint/
```

### 3. Create the symlink

```bash
cd <project>/.claude/commands/
ln -s ../../.library/commands/bmad/bmad-bmm-auto-sprint.md bmad-bmm-auto-sprint.md
```

### 4. Verify

```bash
# Should resolve through symlink
cat <project>/.claude/commands/bmad-bmm-auto-sprint.md
```

## Usage

In Claude Code, run:

```
/bmad-bmm-auto-sprint
```

### Limit scope for testing

In `workflow.yaml`, set:

```yaml
scope_story_limit: 1  # Process only 1 story
```

### Adjust circuit breakers

```yaml
max_iterations: 20          # Absolute cap
max_consecutive_failures: 2  # Stop after N failures in a row
```

## File Structure

```
bmad-auto-sprint/
├── README.md                      # This file
├── bmad-bmm-auto-sprint.md        # Command file → .library/commands/bmad/
└── auto-sprint/                   # Workflow dir → _bmad/bmm/workflows/4-implementation/
    ├── workflow.yaml              # Config, scope, circuit breakers
    └── instructions.xml           # 8-step orchestration logic
```
